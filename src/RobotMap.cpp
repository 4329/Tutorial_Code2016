// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"	//a .cpp file will always include it's .h counterpart
#include "LiveWindow/LiveWindow.h"	//live window is used to display the values of the electrical components
									//during test mode Ex: a IR sensor may show a value of 1.387


std::shared_ptr<CANTalon> RobotMap::Talon_R1;
std::shared_ptr<CANTalon> RobotMap::Talon_R2;
std::shared_ptr<CANTalon> RobotMap::Talon_L1;
std::shared_ptr<CANTalon> RobotMap::Talon_L2;
std::shared_ptr<Solenoid> RobotMap::Shoot_Sol;
std::shared_ptr<CANTalon> RobotMap::Intake_Talon;
std::shared_ptr<DoubleSolenoid> RobotMap::Pivot_Sol;
std::shared_ptr<DoubleSolenoid> RobotMap::Arm_Sol;

void RobotMap::init() {
    LiveWindow *lw = LiveWindow::GetInstance();	//get instance returns instance/object of the live window class
    											//and does so once no matter how m=many times the function is called
    //the pointer (*lw) is a regular pointer and not a smart pointer as it is only used in this file

    //creates a object of the CANTalon class and has the Talon_R1 shared pointer point to the objects memory location
    Talon_R1.reset(new CANTalon(1));
    lw->AddActuator("DriveTrain", "Talon_R1", Talon_R1);	//AddActuator lets us see the data of the talon on the live window
		Talon_L1->SetExpiration(0.1);
    
	//all of these other statements do that same as the one above, but with different electrical components
    Talon_R2.reset(new CANTalon(2));
    lw->AddActuator("DriveTrain", "Talon_R2", Talon_R2);
		Talon_L1->SetExpiration(0.1);
    
    Talon_L1.reset(new CANTalon(3));
    lw->AddActuator("DriveTrain", "Talon_L1", Talon_L1);
    	Talon_L1->SetInverted(true);	//motor moves in the opposite direction as it's on the left side
    	Talon_L1->SetExpiration(0.1);
    
    Talon_L2.reset(new CANTalon(4));	//the 4 is the port that the motor connects to
    lw->AddActuator("DriveTrain", "Talon_L2", Talon_L2);
    	Talon_L2->SetInverted(true);
    
    Shoot_Sol.reset(new Solenoid(1, 1));
    lw->AddActuator("Shooter", "Shoot_Sol", Shoot_Sol);
    
    Intake_Talon.reset(new CANTalon(5));
    lw->AddActuator("Intake", "Intake_Talon", Intake_Talon);
    
    Pivot_Sol.reset(new DoubleSolenoid(0, 0, 1));
    lw->AddActuator("Pivot", "Pivot_Sol", Pivot_Sol);
    
    Arm_Sol.reset(new DoubleSolenoid(0, 2, 3));
    lw->AddActuator("Arm", "Arm_Sol", Arm_Sol);
}

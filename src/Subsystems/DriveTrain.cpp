// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "DriveTrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/Move.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

DriveTrain::DriveTrain() : Subsystem("DriveTrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    talon_R1 = RobotMap::Talon_R1;
    talon_R2 = RobotMap::Talon_R2;
    talon_L1 = RobotMap::Talon_L1;
    talon_L2 = RobotMap::Talon_L2;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SetMode();
}

void DriveTrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new Move());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DriveTrain::ArcadeDrive(float x, float y) {
	float nx = Limit(x);
	float ny = Limit(y);
	float leftMotorOutput, rightMotorOutput;

	//changes output depending on output of the joystick
	if (ny > 0.0)  // If moving forward
		{
			if (nx > 0.0) // If turning/rotating right
			{
				leftMotorOutput = ny - nx;
				rightMotorOutput = std::max(ny, nx);
			}
			else if (nx < 0.0) // If turning/rotating left or not moving
			{
				leftMotorOutput = std::max(ny, -nx);
				rightMotorOutput = ny + nx;
			} else
			{
				leftMotorOutput = ny;
				rightMotorOutput = ny;
			}
		}
		else  // If moving backward
		{
			if (nx > 0.0) // If turning/rotating right
			{
				leftMotorOutput = - std::max(-ny, nx);
				rightMotorOutput = ny + nx;
			}
			else if (nx < 0.0) // If turning/rotating left or not moving
			{
				leftMotorOutput = ny - nx;
				rightMotorOutput = - std::max(-ny, -nx);
			} else
			{
				leftMotorOutput = ny;
				rightMotorOutput = ny;
			}
		}

	//moves motors
	talon_R1->Set(rightMotorOutput);
	talon_R2->Set(rightMotorOutput);
	talon_L1->Set(leftMotorOutput);
	talon_L2->Set(leftMotorOutput);
}

void DriveTrain::Stop() {
	talon_R1->StopMotor();
	talon_R2->StopMotor();
	talon_L1->StopMotor();
	talon_L2->StopMotor();
}

float DriveTrain::Limit(float num) {
	if 		(num > 1) 	{ return 1; }

	else if (num < -1) 	{ return -1; }

	else 				{ return num; }
}

void DriveTrain::SetMode() {
	talon_R1->SetControlMode(talon_R1->kPercentVbus);
	talon_R2->SetControlMode(talon_R1->kPercentVbus);
	talon_L1->SetControlMode(talon_R1->kPercentVbus);
	talon_L2->SetControlMode(talon_R1->kPercentVbus);
}
